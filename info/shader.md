
### 1. **Шейдеры (Shaders)**

Шейдеры — это небольшие программы, которые выполняются на GPU, а не на CPU. Они помогают ускорить обработку графики, так как выполняются параллельно для каждого пикселя или вершины.

#### 1.1. **Типы шейдеров**

- **Вершинный шейдер (Vertex Shader)**: Вершинный шейдер отвечает за обработку данных каждой вершины, таких как координаты, цвет, текстурные координаты и т. д. Его задача — преобразовать вершины из локального пространства объекта в пространство экрана.
    
    Пример простого вершнного шейдера:
    
    ```glsl
    #version 330 core
    layout(location = 0) in vec3 aPos; // Позиция вершины
    void main() {
        gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); // Просто передаем позицию на экран
    }
    ```
    
- **Фрагментный шейдер (Fragment Shader)**: Фрагментный шейдер обрабатывает пиксели на экране. Он вычисляет цвет пикселя на основе различных факторов, таких как текстуры, освещение и цвета. После этого этот цвет передается в буфер фрейма.
    
    Пример простого фрагментного шейдера:
    
    ```glsl
    #version 330 core
    out vec4 FragColor;
    void main() {
        FragColor = vec4(0.4f, 0.7f, 0.1f, 1.0f); // Зеленый цвет
    }
    ```
    
- **Тесселяционный шейдер (Tessellation Shader)** — опциональный шейдер, который используется для увеличения детализации объектов. Он разбивает геометрию на более мелкие части.
    
- **Шейдеры геометрии, вычислений, а также другие** существуют, но для начала достаточно знать о вершинном и фрагментном шейдерах.
    

#### 1.2. **Шейдерная программа**

Шейдеры компилируются отдельно и затем связываются в одну программу. Это позволяет использовать их для рендеринга объектов.

Чтобы создать шейдерную программу, нужно:

1. Создать шейдеры для вершин и фрагментов.
2. Компилировать шейдеры.
3. Линковать их в программу.

Пример:

```cpp
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);
glCompileShader(vertexShader);

GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);
glCompileShader(fragmentShader);

GLuint shaderProgram = glCreateProgram();
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
```

После этого ты можешь использовать шейдерную программу для рендеринга:

```cpp
glUseProgram(shaderProgram);
```

### 2. **Буферы (Buffers)**

Буферы используются для хранения данных (например, вершины, индексы, текстуры и т. д.), которые будут использованы в OpenGL.

#### 2.1. **Vertex Buffer Object (VBO)**

VBO — это объект, который хранит данные о вершинах. Мы создаем VBO для хранения данных (например, координат, нормалей, цветов) и привязываем его к OpenGL.

```cpp
GLuint VBO;
glGenBuffers(1, &VBO);            // Генерация VBO
glBindBuffer(GL_ARRAY_BUFFER, VBO); // Привязка к буферу
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // Загрузка данных в VBO
```

#### 2.2. **Vertex Array Object (VAO)**

VAO — это объект, который хранит информацию о всех атрибутах вершин (например, о VBO и индексе). Он позволяет эффективно работать с данными.

```cpp
GLuint VAO;
glGenVertexArrays(1, &VAO);      // Генерация VAO
glBindVertexArray(VAO);           // Привязка VAO
```

#### 2.3. **Element Buffer Object (EBO)**

EBO используется для хранения индексов вершин, если ты хочешь рисовать фигуры с использованием индексов. Это позволяет избежать дублирования данных для общих вершин.

```cpp
GLuint EBO;
glGenBuffers(1, &EBO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
```

### 3. **Методы отрисовки**

Когда данные подготовлены (с помощью VAO и VBO), ты можешь рисовать объекты. В OpenGL есть несколько основных методов отрисовки:

#### 3.1. **glDrawArrays**

`glDrawArrays` рисует примитивы (например, треугольники) из массива вершин. Это метод используется, когда ты не используешь индексы для указания порядка рисования.

Пример:

```cpp
glDrawArrays(GL_TRIANGLES, 0, 3); // Отрисовываем треугольник (3 вершины)
```

- **GL_TRIANGLES** — тип примитива (треугольник).
- **0** — смещение в массиве вершин.
- **3** — количество вершин.

#### 3.2. **glDrawElements**

`glDrawElements` рисует примитивы, используя индексы для указания, какие вершины из массива использовать.

Пример:

```cpp
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // 6 индексов для 2 треугольников
```

Здесь мы указываем тип примитива, количество индексов и тип индекса (например, целое число).

### 4. **Очистка экрана**

Каждый кадр нужно очищать перед отрисовкой нового, чтобы избежать наложения изображений.

```cpp
glClear(GL_COLOR_BUFFER_BIT); // Очистка экрана
```

Ты можешь использовать `glClearColor` для задания цвета очистки экрана:

```cpp
glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // Цвет фона
```

### 5. **Основные функции для работы с OpenGL**

- **glGenBuffers** — создание буфера.
- **glBindBuffer** — привязка буфера.
- **glBufferData** — загрузка данных в буфер.
- **glVertexAttribPointer** — указание, как интерпретировать данные в буфере.
- **glEnableVertexAttribArray** — активация вершинного атрибута.
- **glUseProgram** — использование шейдерной программы.
- **glDrawArrays / glDrawElements** — отрисовка объектов.
- **glSwapBuffers** — обмен буферов (для отображения на экране).
[[2.1]]